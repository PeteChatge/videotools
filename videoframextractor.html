<!DOCTYPE html>
<html lang="de">
<head>
    <script src="coi-serviceworker.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Frame Extractor</title>
    <style>
		.ffmpeg-status {
			display: none !important;
		}
        :root {
            --bg: #0f0f13;
            --surface: #18181f;
            --surface2: #22222c;
            --border: #2e2e3d;
            --accent: #7c6af7;
            --accent2: #f76a8a;
            --text: #e8e8f0;
            --muted: #7070a0;
            --success: #4ade80;
            --warning: #fbbf24;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
        }

            body::before {
                content: '';
                position: fixed;
                top: -200px;
                left: -200px;
                width: 600px;
                height: 600px;
                background: radial-gradient(circle, rgba(124,106,247,0.1) 0%, transparent 70%);
                pointer-events: none;
                z-index: 0;
            }

        .header {
            text-align: center;
            margin-bottom: 36px;
            position: relative;
            z-index: 1;
        }

            .header h1 {
                font-size: 28px;
                font-weight: 700;
                letter-spacing: 2px;
                background: linear-gradient(135deg, var(--accent), var(--accent2));
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                margin-bottom: 6px;
            }

            .header p {
                color: var(--muted);
                font-size: 13px;
            }

        .container {
            width: 100%;
            max-width: 820px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: relative;
            z-index: 1;
        }

        /* FFMPEG LOADER BANNER */
        .ffmpeg-banner {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 18px 22px;
            display: flex;
            align-items: center;
            gap: 14px;
            font-size: 13px;
        }

            .ffmpeg-banner .fb-icon {
                font-size: 24px;
                flex-shrink: 0;
            }

            .ffmpeg-banner .fb-text {
                flex: 1;
            }

            .ffmpeg-banner .fb-title {
                font-weight: 600;
                margin-bottom: 3px;
            }

            .ffmpeg-banner .fb-sub {
                color: var(--muted);
                font-size: 12px;
            }

        .ffmpeg-status {
            font-size: 11px;
            font-weight: 700;
            padding: 4px 12px;
            border-radius: 20px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .fs-loading {
            background: rgba(251,191,36,0.2);
            color: var(--warning);
        }

        .fs-ready {
            background: rgba(74,222,128,0.2);
            color: var(--success);
        }

        .fs-error {
            background: rgba(247,106,138,0.2);
            color: var(--accent2);
        }

        .ffmpeg-prog-bar {
            height: 3px;
            background: var(--surface2);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
            display: none;
        }

        .ffmpeg-prog-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent2));
            border-radius: 2px;
            transition: width 0.3s;
            width: 0%;
        }

        /* UPLOAD */
        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 48px 40px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s, transform 0.2s;
            background: var(--surface);
        }

            .upload-area:hover, .upload-area.drag {
                border-color: var(--accent);
                background: #1c1c28;
                transform: translateY(-1px);
            }

            .upload-area .icon {
                font-size: 48px;
                display: block;
                margin-bottom: 12px;
            }

            .upload-area .title {
                font-size: 17px;
                font-weight: 600;
                margin-bottom: 6px;
            }

            .upload-area .hint {
                color: var(--muted);
                font-size: 13px;
            }

        #fileInput {
            display: none;
        }

        /* PANEL */
        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 22px 24px;
        }

        .panel-label {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--muted);
            margin-bottom: 14px;
        }

        .interval-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .ibt {
            flex: 1;
            min-width: 70px;
            padding: 10px 14px;
            border-radius: 8px;
            border: 1.5px solid var(--border);
            background: var(--surface2);
            color: var(--muted);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.18s;
            text-align: center;
            user-select: none;
        }

            .ibt:hover {
                border-color: var(--accent);
                color: var(--text);
            }

            .ibt.active {
                border-color: var(--accent);
                background: rgba(124,106,247,0.15);
                color: var(--accent);
            }

        /* TOGGLE */
        .toggle-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 18px;
            padding-top: 18px;
            border-top: 1px solid var(--border);
        }

        .toggle-label {
            font-size: 13px;
            color: var(--text);
            flex: 1;
        }

        .toggle-sub {
            font-size: 11px;
            color: var(--muted);
            display: block;
            margin-top: 2px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            flex-shrink: 0;
        }

            .switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }

        .slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background: var(--surface2);
            border: 1.5px solid var(--border);
            border-radius: 24px;
            transition: 0.25s;
        }

            .slider::before {
                content: '';
                position: absolute;
                width: 16px;
                height: 16px;
                border-radius: 50%;
                left: 3px;
                bottom: 3px;
                background: var(--muted);
                transition: 0.25s;
            }

        input:checked + .slider {
            background: rgba(124,106,247,0.25);
            border-color: var(--accent);
        }

            input:checked + .slider::before {
                transform: translateX(20px);
                background: var(--accent);
            }

        /* FILE LIST */
        .file-list {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
            display: none;
        }

            .file-list.show {
                display: block;
            }

        .fl-header {
            padding: 14px 22px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--muted);
        }

        .badge {
            background: rgba(124,106,247,0.18);
            color: var(--accent);
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 12px;
            letter-spacing: 0;
        }

        .fi {
            display: flex;
            align-items: center;
            padding: 13px 22px;
            border-bottom: 1px solid var(--border);
            gap: 12px;
        }

            .fi:last-child {
                border-bottom: none;
            }

        .fi-icon {
            font-size: 22px;
            flex-shrink: 0;
        }

        .fi-info {
            flex: 1;
            min-width: 0;
        }

        .fi-name {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .fi-meta {
            font-size: 12px;
            color: var(--muted);
            margin-top: 2px;
        }

        .tag {
            font-size: 11px;
            padding: 3px 10px;
            border-radius: 20px;
            font-weight: 600;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tag-wait {
            background: rgba(112,112,160,0.2);
            color: var(--muted);
        }

        .tag-proc {
            background: rgba(251,191,36,0.2);
            color: var(--warning);
        }

        .tag-done {
            background: rgba(74,222,128,0.2);
            color: var(--success);
        }

        .tag-err {
            background: rgba(247,106,138,0.2);
            color: var(--accent2);
        }

        .fi-frames {
            font-size: 12px;
            color: var(--muted);
            flex-shrink: 0;
        }

        .rm-btn {
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            font-size: 15px;
            padding: 4px 6px;
            border-radius: 4px;
            line-height: 1;
            transition: color 0.15s;
        }

            .rm-btn:hover {
                color: var(--accent2);
            }

        /* BUTTONS */
        .action-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            min-width: 140px;
            padding: 14px 24px;
            border-radius: 10px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

            .btn:disabled {
                opacity: 0.35;
                cursor: not-allowed;
            }

                .btn:disabled:hover {
                    transform: none !important;
                    box-shadow: none !important;
                }

        .btn-primary {
            background: linear-gradient(135deg, #7c6af7, #5a4fd4);
            color: #fff;
            box-shadow: 0 4px 18px rgba(124,106,247,0.3);
        }

            .btn-primary:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: 0 8px 28px rgba(124,106,247,0.4);
            }

        .btn-dl {
            background: linear-gradient(135deg, #f76a8a, #c44465);
            color: #fff;
            box-shadow: 0 4px 18px rgba(247,106,138,0.3);
        }

            .btn-dl:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: 0 8px 28px rgba(247,106,138,0.4);
            }

        .btn-ghost {
            background: var(--surface2);
            color: var(--muted);
            border: 1px solid var(--border);
        }

            .btn-ghost:hover:not(:disabled) {
                color: var(--text);
                border-color: var(--accent);
            }

        /* PROGRESS */
        .progress-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 22px 24px;
            display: none;
        }

            .progress-panel.show {
                display: block;
            }

        .prog-top {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 10px;
        }

            .prog-top span:last-child {
                color: var(--accent);
                font-weight: 700;
            }

        .prog-bar {
            height: 6px;
            background: var(--surface2);
            border-radius: 3px;
            overflow: hidden;
        }

        .prog-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent2));
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .prog-detail {
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px;
            min-height: 18px;
        }

        /* SUMMARY */
        .summary {
            background: var(--surface);
            border: 1px solid var(--success);
            border-radius: 16px;
            padding: 30px 24px;
            text-align: center;
            display: none;
        }

            .summary.show {
                display: block;
            }

            .summary .s-icon {
                font-size: 44px;
                margin-bottom: 10px;
            }

            .summary h2 {
                font-size: 20px;
                font-weight: 700;
                color: var(--success);
                margin-bottom: 6px;
            }

            .summary p {
                color: var(--muted);
                font-size: 14px;
                margin-bottom: 20px;
            }

        canvas {
            display: none;
        }

        @media (max-width: 580px) {
            .action-row {
                flex-direction: column;
            }

            .btn {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>

<div class="header">
    <h1>&#9658; FRAME EXTRACTOR</h1>
    <p>Batch &middot; Intervalle &middot; MP4-Trimming &middot; ZIP &mdash; 100% lokal &middot; alle Browser</p>
</div>

<div class="container">

    <!-- FFmpeg Status Banner -->
    <div class="ffmpeg-banner" id="ffmpegBanner">
        <span class="fb-icon">&#9881;&#65039;</span>
        <div class="fb-text">
            <div class="fb-title">FFmpeg wird geladen</div>
            <div class="fb-sub" id="ffmpegSub">Einmalig ~30 MB &ndash; danach vom Browser gecacht</div>
            <div class="ffmpeg-prog-bar" id="ffmpegProgBar">
                <div class="ffmpeg-prog-fill" id="ffmpegProgFill"></div>
            </div>
        </div>
        <span class="ffmpeg-status fs-loading" id="ffmpegStatus">L&auml;dt …</span>
    </div>

    <!-- Upload -->
    <div class="upload-area" id="uploadArea">
        <span class="icon">&#128193;</span>
        <div class="title">Videos hierher ziehen oder klicken</div>
        <div class="hint">Bis zu 10 Videos gleichzeitig &middot; MP4, MOV, WebM, AVI, MKV</div>
    </div>
    <input type="file" id="fileInput" accept="video/*" multiple>

    <!-- Settings -->
    <div class="panel">
        <div class="panel-label">Frame-Intervall (Endframes)</div>
        <div class="interval-row">
            <div class="ibt active" data-v="5">Jedes 5.</div>
            <div class="ibt" data-v="10">Jedes 10.</div>
            <div class="ibt" data-v="15">Jedes 15.</div>
            <div class="ibt" data-v="20">Jedes 20.</div>
            <div class="ibt" data-v="25">Jedes 25.</div>
            <div class="ibt" data-v="last">Nur Letztes</div>
        </div>
        <div class="toggle-row">
            <div class="toggle-label">
                Ersten Frame entfernen (MP4)
                <span class="toggle-sub">Verhindert Ruckler beim Zusammenf&uuml;gen &mdash; funktioniert in allen Browsern inkl. iPhone</span>
            </div>
            <label class="switch">
                <input type="checkbox" id="trimToggle" checked>
                <span class="slider"></span>
            </label>
        </div>
    </div>

    <!-- File list -->
    <div class="file-list" id="fileList">
        <div class="fl-header">
            <span>Warteschlange</span>
            <span class="badge" id="fileCount">0 Videos</span>
        </div>
        <div id="fileItems"></div>
    </div>

    <!-- Actions -->
    <div class="action-row">
        <button class="btn btn-primary" id="startBtn" disabled>&#9889; Verarbeitung starten</button>
        <button class="btn btn-ghost" id="resetBtn">&#10005; Zur&uuml;cksetzen</button>
    </div>

    <!-- Progress -->
    <div class="progress-panel" id="progressPanel">
        <div class="prog-top">
            <span id="progLabel">Verarbeite...</span>
            <span id="progPct">0%</span>
        </div>
        <div class="prog-bar"><div class="prog-fill" id="progFill"></div></div>
        <div class="prog-detail" id="progDetail"></div>
    </div>

    <!-- Summary -->
    <div class="summary" id="summary">
        <div class="s-icon">&#9989;</div>
        <h2>Fertig!</h2>
        <p id="summaryText"></p>
        <button class="btn btn-dl" id="dlBtn" style="max-width:280px;margin:0 auto;">&#128230; ZIP herunterladen</button>
    </div>

</div>

<canvas id="canvas"></canvas>

<script>
// ═══════════════════════════════════════════════════════════
// MiniZip (offline, kein CDN)
// ═══════════════════════════════════════════════════════════
const MiniZip = (() => {
    const enc = new TextEncoder();
    function u16(n){const b=new Uint8Array(2);b[0]=n&0xFF;b[1]=(n>>8)&0xFF;return b;}
    function u32(n){const b=new Uint8Array(4);b[0]=n&0xFF;b[1]=(n>>8)&0xFF;b[2]=(n>>16)&0xFF;b[3]=(n>>24)&0xFF;return b;}
    const T=new Uint32Array(256);
    for(let i=0;i<256;i++){let c=i;for(let j=0;j<8;j++)c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1);T[i]=c;}
    function crc32(buf){let c=0xFFFFFFFF;for(let i=0;i<buf.length;i++)c=T[(c^buf[i])&0xFF]^(c>>>8);return(c^0xFFFFFFFF)>>>0;}
    function concat(...arrs){const tot=arrs.reduce((s,a)=>s+a.length,0),out=new Uint8Array(tot);let o=0;for(const a of arrs){out.set(a,o);o+=a.length;}return out;}
    async function deflateData(data){
        if(typeof CompressionStream==='undefined')return null;
        try{
            const cs=new CompressionStream('deflate-raw'),w=cs.writable.getWriter();
            w.write(data);w.close();
            const chunks=[],r=cs.readable.getReader();
            for(;;){const{done,value}=await r.read();if(done)break;chunks.push(value);}
            return concat(...chunks);
        }catch(e){return null;}
    }
    return {
        async build(files){
            const lparts=[],cdparts=[];let offset=0;
            const now=new Date();
            const dosTime=((now.getHours()<<11)|(now.getMinutes()<<5)|(now.getSeconds()>>1))&0xFFFF;
            const dosDate=(((now.getFullYear()-1980)<<9)|((now.getMonth()+1)<<5)|now.getDate())&0xFFFF;
            for(const f of files){
                const nb=enc.encode(f.name),crc=crc32(f.data),us=f.data.length;
                let comp=await deflateData(f.data),method=8;
                if(!comp||comp.length>=f.data.length){comp=f.data;method=0;}
                const lfh=concat(new Uint8Array([0x50,0x4B,0x03,0x04]),u16(20),u16(0),u16(method),u16(dosTime),u16(dosDate),u32(crc),u32(comp.length),u32(us),u16(nb.length),u16(0),nb);
                lparts.push(lfh,comp);
                cdparts.push(concat(new Uint8Array([0x50,0x4B,0x01,0x02]),u16(20),u16(20),u16(0),u16(method),u16(dosTime),u16(dosDate),u32(crc),u32(comp.length),u32(us),u16(nb.length),u16(0),u16(0),u16(0),u16(0),u32(0),u32(offset),nb));
                offset+=lfh.length+comp.length;
            }
            const cd=concat(...cdparts);
            const eocd=concat(new Uint8Array([0x50,0x4B,0x05,0x06]),u16(0),u16(0),u16(files.length),u16(files.length),u32(cd.length),u32(offset),u16(0));
            return concat(...lparts,cd,eocd);
        }
    };
})();

// ═══════════════════════════════════════════════════════════
// FFmpeg WASM laden (via ESM CDN – einmalig, danach gecacht)
// ═══════════════════════════════════════════════════════════
let ffmpegReady = false;
let ffmpegFailed = false;
let ffmpeg = null;
let FFmpegLib = null;

const ffmpegBanner  = document.getElementById('ffmpegBanner');
const ffmpegStatus  = document.getElementById('ffmpegStatus');
const ffmpegSub     = document.getElementById('ffmpegSub');
const ffmpegProgBar = document.getElementById('ffmpegProgBar');
const ffmpegProgFill= document.getElementById('ffmpegProgFill');

async function loadFFmpeg() {
    try {
        ffmpegProgBar.style.display = 'block';

        // Dynamischer ESM-Import von ffmpeg.wasm (v0.12 – unterstützt Safari/iOS)
        const { FFmpeg } = await import('https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm/index.js');
        const { fetchFile, toBlobURL } = await import('https://unpkg.com/@ffmpeg/util@0.12.1/dist/esm/index.js');

        FFmpegLib = { fetchFile, toBlobURL };

        ffmpeg = new FFmpeg();

        ffmpeg.on('progress', ({ progress }) => {
            const pct = Math.round(progress * 100);
            ffmpegProgFill.style.width = pct + '%';
        });

        ffmpeg.on('log', ({ message }) => {
            // optional: console.log('[ffmpeg]', message);
        });

        // Core laden – toBlobURL setzt nötige COOP/COEP-Header für SharedArrayBuffer
        const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm';
        await ffmpeg.load({
            coreURL: await toBlobURL(baseURL + '/ffmpeg-core.js',   'text/javascript'),
            wasmURL: await toBlobURL(baseURL + '/ffmpeg-core.wasm', 'application/wasm'),
        });

        ffmpegReady = true;
        ffmpegStatus.textContent = 'Bereit';
        ffmpegStatus.className = 'ffmpeg-status fs-ready';
        ffmpegSub.textContent = 'MP4-Trimming verfügbar – funktioniert in allen Browsern';
        ffmpegProgBar.style.display = 'none';

        // Start-Button freigeben falls schon Dateien da sind
        updateStartBtn();

    } catch(err) {
        ffmpegFailed = true;
        ffmpegStatus.textContent = 'Nicht verfügbar';
        ffmpegStatus.className = 'ffmpeg-status fs-error';
        ffmpegSub.textContent = 'Kein Internet? Trimming wird übersprungen. Frames funktionieren weiterhin.';
        ffmpegProgBar.style.display = 'none';
        console.warn('FFmpeg konnte nicht geladen werden:', err);
        updateStartBtn();
    }
}

loadFFmpeg();

// ═══════════════════════════════════════════════════════════
// App State
// ═══════════════════════════════════════════════════════════
let videoFiles = [];
let interval   = 5;
let zipBlob    = null;

const uploadArea    = document.getElementById('uploadArea');
const fileInput     = document.getElementById('fileInput');
const fileList      = document.getElementById('fileList');
const fileItems     = document.getElementById('fileItems');
const fileCount     = document.getElementById('fileCount');
const startBtn      = document.getElementById('startBtn');
const resetBtn      = document.getElementById('resetBtn');
const trimToggle    = document.getElementById('trimToggle');
const progressPanel = document.getElementById('progressPanel');
const progLabel     = document.getElementById('progLabel');
const progPct       = document.getElementById('progPct');
const progFill      = document.getElementById('progFill');
const progDetail    = document.getElementById('progDetail');
const summary       = document.getElementById('summary');
const summaryText   = document.getElementById('summaryText');
const dlBtn         = document.getElementById('dlBtn');
const canvas        = document.getElementById('canvas');
const ctx           = canvas.getContext('2d');

function updateStartBtn() {
    startBtn.disabled = videoFiles.length === 0 || (!ffmpegReady && !ffmpegFailed);
}

// Interval buttons
document.querySelectorAll('.ibt').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.ibt').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        interval = btn.dataset.v === 'last' ? 'last' : parseInt(btn.dataset.v);
    });
});

// Upload
uploadArea.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => addFiles([...e.target.files]));
uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('drag'); });
uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('drag'));
uploadArea.addEventListener('drop', e => {
    e.preventDefault(); uploadArea.classList.remove('drag');
    addFiles([...e.dataTransfer.files].filter(f => f.type.startsWith('video/')));
});

function addFiles(files) {
    const room = 10 - videoFiles.length;
    if (room <= 0) { alert('Maximal 10 Videos erlaubt.'); return; }
    const toAdd = files.slice(0, room);
    if (files.length > room) alert('Nur noch ' + room + ' Platz. Es wurden ' + room + ' hinzugefügt.');
    toAdd.forEach(f => {
        if (!f.type.startsWith('video/')) return;
        videoFiles.push({ file: f, status: 'waiting', frames: 0 });
    });
    renderList();
    fileInput.value = '';
}

function renderList() {
    fileItems.innerHTML = '';
    fileCount.textContent = videoFiles.length + ' Video' + (videoFiles.length !== 1 ? 's' : '');
    fileList.classList.toggle('show', videoFiles.length > 0);
    updateStartBtn();

    const labels = { waiting: 'Wartend', processing: 'Verarbeite …', done: 'Fertig', error: 'Fehler' };
    const tagCls = { waiting: 'tag-wait', processing: 'tag-proc', done: 'tag-done', error: 'tag-err' };

    videoFiles.forEach((e, i) => {
        const div = document.createElement('div');
        div.className = 'fi';
        const rmBtn = e.status === 'waiting' ? '<button class="rm-btn" data-i="' + i + '">&#10005;</button>' : '';
        const framesHtml = e.frames > 0 ? '<span class="fi-frames">' + e.frames + ' Frames</span>' : '';
        div.innerHTML =
            '<span class="fi-icon">&#127909;</span>' +
            '<div class="fi-info">' +
                '<div class="fi-name" title="' + e.file.name + '">' + e.file.name + '</div>' +
                '<div class="fi-meta">' + (e.file.size / 1048576).toFixed(1) + ' MB</div>' +
            '</div>' +
            framesHtml +
            '<span class="tag ' + tagCls[e.status] + '">' + labels[e.status] + '</span>' +
            rmBtn;
        fileItems.appendChild(div);
    });
    document.querySelectorAll('.rm-btn').forEach(b => {
        b.addEventListener('click', () => { videoFiles.splice(parseInt(b.dataset.i), 1); renderList(); });
    });
}

resetBtn.addEventListener('click', () => {
    videoFiles = []; zipBlob = null;
    renderList();
    progressPanel.classList.remove('show');
    summary.classList.remove('show');
    progFill.style.width = '0%';
});

// ═══════════════════════════════════════════════════════════
// MAIN PROCESSING
// ═══════════════════════════════════════════════════════════
startBtn.addEventListener('click', async () => {
    if (!videoFiles.length) return;
    startBtn.disabled = true;
    resetBtn.disabled = true;
    summary.classList.remove('show');
    progressPanel.classList.add('show');

    const doTrim   = trimToggle.checked && ffmpegReady;
    const allFiles = [];
    let totalFrames = 0;

    for (let i = 0; i < videoFiles.length; i++) {
        const entry = videoFiles[i];
        entry.status = 'processing';
        renderList();
        setProgress(i, videoFiles.length, 'Video ' + (i+1) + '/' + videoFiles.length + ': ' + entry.file.name, '');

        try {
            const baseName = entry.file.name.replace(/\.[^/.]+$/, '');

            // 1. Frames extrahieren
            progDetail.textContent = 'Extrahiere Frames …';
            const frames = await extractFrames(entry.file, interval, msg => { progDetail.textContent = msg; });
            frames.forEach(f => allFiles.push({ name: baseName + '/frames/' + f.name, data: f.data }));
            totalFrames += frames.length;

            // 2. Clip trimmen (ffmpeg: erster Frame weg → MP4)
            if (doTrim) {
                progDetail.textContent = 'Trimme Clip mit FFmpeg …';
                const mp4Data = await trimWithFFmpeg(entry.file, baseName, msg => { progDetail.textContent = msg; });
                if (mp4Data) {
                    allFiles.push({ name: baseName + '/' + baseName + '_trimmed.mp4', data: mp4Data });
                }
            }

            entry.status = 'done';
            entry.frames = frames.length;
        } catch (err) {
            entry.status = 'error';
            console.error(err);
        }
        renderList();
    }

    progLabel.textContent = 'ZIP wird erstellt …';
    progDetail.textContent = allFiles.length + ' Dateien werden gepackt …';
    progFill.style.width = '95%'; progPct.textContent = '…';

    const zipBytes = await MiniZip.build(allFiles);
    zipBlob = new Blob([zipBytes], { type: 'application/zip' });

    progressPanel.classList.remove('show');
    summary.classList.add('show');
    const doneCount = videoFiles.filter(e => e.status === 'done').length;
    summaryText.textContent =
        doneCount + ' Video' + (doneCount !== 1 ? 's' : '') + ' verarbeitet · ' +
        totalFrames + ' Frames extrahiert' +
        (doTrim ? ' · Clips als MP4 getrimmt' : '');
    resetBtn.disabled = false;
});

dlBtn.addEventListener('click', () => {
    if (!zipBlob) return;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(zipBlob);
    a.download = 'frames_export.zip';
    a.click();
});

function setProgress(done, total, label, detail) {
    const pct = total > 0 ? Math.round(done / total * 100) : 0;
    progFill.style.width = pct + '%';
    progPct.textContent = pct + '%';
    progLabel.textContent = label;
    progDetail.textContent = detail;
}

// ═══════════════════════════════════════════════════════════
// FRAME EXTRACTION (canvas-basiert, überall unterstützt)
// ═══════════════════════════════════════════════════════════
function extractFrames(file, iv, onProgress) {
    return new Promise((resolve, reject) => {
        const url   = URL.createObjectURL(file);
        const video = document.createElement('video');
        video.muted = true; video.preload = 'auto';
        video.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Videofehler')); };

        video.addEventListener('loadedmetadata', async () => {
            const duration = video.duration;
            const fps = 30;
            const totalFrameCount = Math.round(duration * fps);

            canvas.width  = video.videoWidth  || 1280;
            canvas.height = video.videoHeight || 720;

            let times = [];
            if (iv === 'last') {
                times = [Math.max(0, duration - 0.05)];
            } else {
                for (let f = iv - 1; f < totalFrameCount; f += iv) times.push(f / fps);
                const lastT = Math.max(0, duration - 0.05);
                if (!times.length || times[times.length - 1] < lastT - 0.1) times.push(lastT);
            }

            const results = [];
            for (let i = 0; i < times.length; i++) {
                try {
                    const blob = await seekCapture(video, times[i]);
                    const arr  = await blob.arrayBuffer();
                    const frameNum = iv === 'last'
                        ? 'last'
                        : String(Math.round(times[i] * fps) + 1).padStart(6, '0');
                    results.push({ name: 'frame_' + frameNum + '.jpg', data: new Uint8Array(arr) });
                    onProgress('Frame ' + (i+1) + ' / ' + times.length);
                } catch(e) { /* skip */ }
            }

            URL.revokeObjectURL(url);
            video.remove();
            resolve(results);
        });

        video.src = url;
        video.load();
    });
}

function seekCapture(video, time) {
    return new Promise((resolve, reject) => {
        const tid = setTimeout(() => reject(new Error('Timeout')), 12000);
        video.onseeked = () => {
            clearTimeout(tid); video.onseeked = null;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(b => b ? resolve(b) : reject(new Error('Blob-Fehler')), 'image/jpeg', 0.92);
        };
        video.currentTime = time;
    });
}

// ═══════════════════════════════════════════════════════════
// FFMPEG TRIMMING – erster Frame entfernen, MP4 ausgeben
// Funktioniert in Chrome, Firefox, Safari, iOS Safari
// ═══════════════════════════════════════════════════════════
async function trimWithFFmpeg(file, baseName, onProgress) {
    try {
        const { fetchFile } = FFmpegLib;

        // Eingabedatei in FFmpeg-FS schreiben
        const inputName  = 'input_' + Date.now() + '.' + (file.name.split('.').pop() || 'mp4');
        const outputName = 'output_' + Date.now() + '.mp4';

        onProgress('Lade Video in FFmpeg …');
        await ffmpeg.writeFile(inputName, await fetchFile(file));

        // Fortschritts-Listener für diesen Clip
        const onProg = ({ progress }) => {
            onProgress('FFmpeg kodiert: ' + Math.round(progress * 100) + '%');
        };
        ffmpeg.on('progress', onProg);

        // FFmpeg-Kommando:
        // -ss 0.034  → überspringe ~1 Frame (bei 30fps = 1/30 ≈ 0.0333s)
        // -i input   → Eingabe
        // -c:v libx264 -crf 18 → H.264, hohe Qualität
        // -c:a aac   → Audio beibehalten
        // -movflags +faststart → MP4 für Web optimieren
        // -y         → überschreiben ohne Nachfrage
        await ffmpeg.exec([
            '-ss', '0.034',
            '-i', inputName,
            '-c:v', 'libx264',
            '-crf', '18',
            '-preset', 'fast',
            '-c:a', 'aac',
            '-movflags', '+faststart',
            '-y',
            outputName
        ]);

        ffmpeg.off('progress', onProg);

        // Ausgabe lesen und aufräumen
        const data = await ffmpeg.readFile(outputName);
        await ffmpeg.deleteFile(inputName);
        await ffmpeg.deleteFile(outputName);

        onProgress('Clip fertig getrimmt ✓');
        return data instanceof Uint8Array ? data : new Uint8Array(data);

    } catch(err) {
        console.error('FFmpeg Trimming fehlgeschlagen:', err);
        return null;
    }
}
</script>
</body>
</html>
