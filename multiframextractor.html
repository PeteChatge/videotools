<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Frame Extractor</title>
    <style>
        :root {
            --bg: #0f0f13;
            --surface: #18181f;
            --surface2: #22222c;
            --border: #2e2e3d;
            --accent: #7c6af7;
            --accent2: #f76a8a;
            --text: #e8e8f0;
            --muted: #7070a0;
            --success: #4ade80;
            --warning: #fbbf24;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
        }

        body::before {
            content: '';
            position: fixed;
            top: -200px; left: -200px;
            width: 600px; height: 600px;
            background: radial-gradient(circle, rgba(124,106,247,0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 36px;
            position: relative;
            z-index: 1;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 2px;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 6px;
        }

        .header p { color: var(--muted); font-size: 13px; }

        .container {
            width: 100%;
            max-width: 820px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: relative;
            z-index: 1;
        }

        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 48px 40px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s, transform 0.2s;
            background: var(--surface);
        }

        .upload-area:hover, .upload-area.drag { border-color: var(--accent); background: #1c1c28; transform: translateY(-1px); }

        .upload-area .icon { font-size: 48px; display: block; margin-bottom: 12px; }
        .upload-area .title { font-size: 17px; font-weight: 600; margin-bottom: 6px; }
        .upload-area .hint { color: var(--muted); font-size: 13px; }
        #fileInput { display: none; }

        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 22px 24px;
        }

        .panel-label {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--muted);
            margin-bottom: 14px;
        }

        .interval-row { display: flex; gap: 8px; flex-wrap: wrap; }

        .ibt {
            flex: 1;
            min-width: 70px;
            padding: 10px 14px;
            border-radius: 8px;
            border: 1.5px solid var(--border);
            background: var(--surface2);
            color: var(--muted);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.18s;
            text-align: center;
            user-select: none;
        }

        .ibt:hover { border-color: var(--accent); color: var(--text); }
        .ibt.active { border-color: var(--accent); background: rgba(124,106,247,0.15); color: var(--accent); }

        .file-list { background: var(--surface); border: 1px solid var(--border); border-radius: 16px; overflow: hidden; display: none; }
        .file-list.show { display: block; }

        .fl-header {
            padding: 14px 22px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--muted);
        }

        .badge {
            background: rgba(124,106,247,0.18);
            color: var(--accent);
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 12px;
            letter-spacing: 0;
        }

        .fi {
            display: flex;
            align-items: center;
            padding: 13px 22px;
            border-bottom: 1px solid var(--border);
            gap: 12px;
        }
        .fi:last-child { border-bottom: none; }

        .fi-icon { font-size: 22px; flex-shrink: 0; }
        .fi-info { flex: 1; min-width: 0; }
        .fi-name { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .fi-meta { font-size: 12px; color: var(--muted); margin-top: 2px; }

        .tag {
            font-size: 11px;
            padding: 3px 10px;
            border-radius: 20px;
            font-weight: 600;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .tag-wait { background: rgba(112,112,160,0.2); color: var(--muted); }
        .tag-proc { background: rgba(251,191,36,0.2); color: var(--warning); }
        .tag-done { background: rgba(74,222,128,0.2); color: var(--success); }
        .tag-err  { background: rgba(247,106,138,0.2); color: var(--accent2); }

        .fi-frames { font-size: 12px; color: var(--muted); flex-shrink: 0; }

        .rm-btn {
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            font-size: 15px;
            padding: 4px 6px;
            border-radius: 4px;
            line-height: 1;
            transition: color 0.15s;
        }
        .rm-btn:hover { color: var(--accent2); }

        .action-row { display: flex; gap: 12px; flex-wrap: wrap; }

        .btn {
            flex: 1;
            min-width: 140px;
            padding: 14px 24px;
            border-radius: 10px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:disabled { opacity: 0.35; cursor: not-allowed; }
        .btn:disabled:hover { transform: none !important; box-shadow: none !important; }

        .btn-primary { background: linear-gradient(135deg, #7c6af7, #5a4fd4); color: #fff; box-shadow: 0 4px 18px rgba(124,106,247,0.3); }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 8px 28px rgba(124,106,247,0.4); }

        .btn-dl { background: linear-gradient(135deg, #f76a8a, #c44465); color: #fff; box-shadow: 0 4px 18px rgba(247,106,138,0.3); }
        .btn-dl:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 8px 28px rgba(247,106,138,0.4); }

        .btn-ghost { background: var(--surface2); color: var(--muted); border: 1px solid var(--border); }
        .btn-ghost:hover:not(:disabled) { color: var(--text); border-color: var(--accent); }

        .progress-panel { background: var(--surface); border: 1px solid var(--border); border-radius: 16px; padding: 22px 24px; display: none; }
        .progress-panel.show { display: block; }

        .prog-top { display: flex; justify-content: space-between; font-size: 13px; margin-bottom: 10px; }
        .prog-top span:last-child { color: var(--accent); font-weight: 700; }

        .prog-bar { height: 6px; background: var(--surface2); border-radius: 3px; overflow: hidden; }
        .prog-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); border-radius: 3px; transition: width 0.3s ease; width: 0%; }
        .prog-detail { font-size: 12px; color: var(--muted); margin-top: 8px; }

        .summary { background: var(--surface); border: 1px solid var(--success); border-radius: 16px; padding: 30px 24px; text-align: center; display: none; }
        .summary.show { display: block; }
        .summary .s-icon { font-size: 44px; margin-bottom: 10px; }
        .summary h2 { font-size: 20px; font-weight: 700; color: var(--success); margin-bottom: 6px; }
        .summary p { color: var(--muted); font-size: 14px; margin-bottom: 20px; }

        canvas, video { display: none; }

        @media (max-width: 580px) {
            .action-row { flex-direction: column; }
            .btn { min-width: 100%; }
        }
    </style>
</head>
<body>

<div class="header">
    <h1>&#9658; FRAME EXTRACTOR</h1>
    <p>Batch &middot; Intervalle &middot; ZIP &mdash; 100% lokal, keine Uploads</p>
</div>

<div class="container">

    <div class="upload-area" id="uploadArea">
        <span class="icon">&#128193;</span>
        <div class="title">Videos hierher ziehen oder klicken</div>
        <div class="hint">Bis zu 10 Videos gleichzeitig &middot; MP4, MOV, WebM, AVI, MKV</div>
    </div>
    <input type="file" id="fileInput" accept="video/*" multiple>

    <div class="panel">
        <div class="panel-label">Frame-Intervall</div>
        <div class="interval-row">
            <div class="ibt active" data-v="5">Jedes 5.</div>
            <div class="ibt" data-v="10">Jedes 10.</div>
            <div class="ibt" data-v="15">Jedes 15.</div>
            <div class="ibt" data-v="20">Jedes 20.</div>
            <div class="ibt" data-v="25">Jedes 25.</div>
            <div class="ibt" data-v="last">Nur Letztes</div>
        </div>
    </div>

    <div class="file-list" id="fileList">
        <div class="fl-header">
            <span>Warteschlange</span>
            <span class="badge" id="fileCount">0 Videos</span>
        </div>
        <div id="fileItems"></div>
    </div>

    <div class="action-row">
        <button class="btn btn-primary" id="startBtn" disabled>&#9889; Verarbeitung starten</button>
        <button class="btn btn-ghost" id="resetBtn">&#10005; Zur&uuml;cksetzen</button>
    </div>

    <div class="progress-panel" id="progressPanel">
        <div class="prog-top">
            <span id="progLabel">Verarbeite...</span>
            <span id="progPct">0%</span>
        </div>
        <div class="prog-bar"><div class="prog-fill" id="progFill"></div></div>
        <div class="prog-detail" id="progDetail"></div>
    </div>

    <div class="summary" id="summary">
        <div class="s-icon">&#9989;</div>
        <h2>Fertig!</h2>
        <p id="summaryText"></p>
        <button class="btn btn-dl" id="dlBtn" style="max-width:280px;margin:0 auto;">&#128230; ZIP herunterladen</button>
    </div>

</div>

<canvas id="canvas"></canvas>

<script>
// ═══════════════════════════════════════════════════════════
// Schlanke ZIP-Implementierung (kein externes CDN nötig)
// ═══════════════════════════════════════════════════════════
const MiniZip = (() => {
    const enc = new TextEncoder();

    function u16(n) {
        const b = new Uint8Array(2);
        b[0] = n & 0xFF; b[1] = (n >> 8) & 0xFF;
        return b;
    }
    function u32(n) {
        const b = new Uint8Array(4);
        b[0] = n & 0xFF; b[1] = (n >> 8) & 0xFF; b[2] = (n >> 16) & 0xFF; b[3] = (n >> 24) & 0xFF;
        return b;
    }

    // Build CRC32 table
    const crcTable = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        crcTable[i] = c;
    }
    function crc32(buf) {
        let c = 0xFFFFFFFF;
        for (let i = 0; i < buf.length; i++) c = crcTable[(c ^ buf[i]) & 0xFF] ^ (c >>> 8);
        return (c ^ 0xFFFFFFFF) >>> 0;
    }

    function concat(...arrays) {
        const total = arrays.reduce((s, a) => s + a.length, 0);
        const out = new Uint8Array(total);
        let off = 0;
        for (const a of arrays) { out.set(a, off); off += a.length; }
        return out;
    }

    async function deflateData(data) {
        if (typeof CompressionStream === 'undefined') return null;
        try {
            const cs = new CompressionStream('deflate-raw');
            const w = cs.writable.getWriter();
            w.write(data); w.close();
            const chunks = [];
            const r = cs.readable.getReader();
            for (;;) { const {done, value} = await r.read(); if (done) break; chunks.push(value); }
            return concat(...chunks);
        } catch(e) { return null; }
    }

    return {
        async build(files) {
            // files: [{name:string, data:Uint8Array}]
            const localParts = [];
            const cdParts = [];
            let offset = 0;
            const now = new Date();
            const dosTime = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() >> 1)) & 0xFFFF;
            const dosDate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate()) & 0xFFFF;

            for (const f of files) {
                const nameBytes = enc.encode(f.name);
                const crc = crc32(f.data);
                const uSize = f.data.length;

                let comp = await deflateData(f.data);
                let method = 8;
                if (!comp || comp.length >= f.data.length) { comp = f.data; method = 0; }

                // Local file header
                const lfh = concat(
                    new Uint8Array([0x50,0x4B,0x03,0x04]),
                    u16(20), u16(0), u16(method),
                    u16(dosTime), u16(dosDate),
                    u32(crc), u32(comp.length), u32(uSize),
                    u16(nameBytes.length), u16(0),
                    nameBytes
                );

                localParts.push(lfh, comp);

                // Central directory entry
                cdParts.push(concat(
                    new Uint8Array([0x50,0x4B,0x01,0x02]),
                    u16(20), u16(20), u16(0), u16(method),
                    u16(dosTime), u16(dosDate),
                    u32(crc), u32(comp.length), u32(uSize),
                    u16(nameBytes.length), u16(0), u16(0), u16(0), u16(0),
                    u32(0), u32(offset),
                    nameBytes
                ));

                offset += lfh.length + comp.length;
            }

            const cd = concat(...cdParts);
            const eocd = concat(
                new Uint8Array([0x50,0x4B,0x05,0x06]),
                u16(0), u16(0),
                u16(files.length), u16(files.length),
                u32(cd.length), u32(offset),
                u16(0)
            );

            return concat(...localParts, cd, eocd);
        }
    };
})();

// ═══════════════════════════════════════════════════════════
// App-Logik
// ═══════════════════════════════════════════════════════════
let videoFiles = [];
let interval = 5;
let zipBlob = null;

const uploadArea  = document.getElementById('uploadArea');
const fileInput   = document.getElementById('fileInput');
const fileList    = document.getElementById('fileList');
const fileItems   = document.getElementById('fileItems');
const fileCount   = document.getElementById('fileCount');
const startBtn    = document.getElementById('startBtn');
const resetBtn    = document.getElementById('resetBtn');
const progressPanel = document.getElementById('progressPanel');
const progLabel   = document.getElementById('progLabel');
const progPct     = document.getElementById('progPct');
const progFill    = document.getElementById('progFill');
const progDetail  = document.getElementById('progDetail');
const summary     = document.getElementById('summary');
const summaryText = document.getElementById('summaryText');
const dlBtn       = document.getElementById('dlBtn');
const canvas      = document.getElementById('canvas');
const ctx         = canvas.getContext('2d');

// Interval
document.querySelectorAll('.ibt').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.ibt').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        interval = btn.dataset.v === 'last' ? 'last' : parseInt(btn.dataset.v);
    });
});

// Upload
uploadArea.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => addFiles([...e.target.files]));
uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('drag'); });
uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('drag'));
uploadArea.addEventListener('drop', e => {
    e.preventDefault(); uploadArea.classList.remove('drag');
    addFiles([...e.dataTransfer.files].filter(f => f.type.startsWith('video/')));
});

function addFiles(files) {
    const room = 10 - videoFiles.length;
    if (room <= 0) { alert('Maximal 10 Videos erlaubt.'); return; }
    const toAdd = files.slice(0, room);
    if (files.length > room) alert('Nur noch ' + room + ' Platz verfügbar. Es wurden ' + room + ' hinzugefügt.');
    toAdd.forEach(f => {
        if (!f.type.startsWith('video/')) return;
        videoFiles.push({ file: f, status: 'waiting', frames: 0 });
    });
    renderList();
    fileInput.value = '';
}

function renderList() {
    fileItems.innerHTML = '';
    fileCount.textContent = videoFiles.length + ' Video' + (videoFiles.length !== 1 ? 's' : '');
    fileList.classList.toggle('show', videoFiles.length > 0);
    startBtn.disabled = videoFiles.length === 0;

    const labels = { waiting: 'Wartend', processing: 'Verarbeite …', done: 'Fertig', error: 'Fehler' };
    const tagCls = { waiting: 'tag-wait', processing: 'tag-proc', done: 'tag-done', error: 'tag-err' };

    videoFiles.forEach((e, i) => {
        const div = document.createElement('div');
        div.className = 'fi';
        const rmBtn = e.status === 'waiting'
            ? '<button class="rm-btn" data-i="' + i + '" title="Entfernen">&#10005;</button>'
            : '';
        const framesHtml = e.frames > 0
            ? '<span class="fi-frames">' + e.frames + ' Frames</span>'
            : '';
        div.innerHTML =
            '<span class="fi-icon">&#127909;</span>' +
            '<div class="fi-info">' +
                '<div class="fi-name" title="' + e.file.name + '">' + e.file.name + '</div>' +
                '<div class="fi-meta">' + (e.file.size / 1048576).toFixed(1) + ' MB</div>' +
            '</div>' +
            framesHtml +
            '<span class="tag ' + tagCls[e.status] + '">' + labels[e.status] + '</span>' +
            rmBtn;
        fileItems.appendChild(div);
    });

    document.querySelectorAll('.rm-btn').forEach(b => {
        b.addEventListener('click', () => {
            videoFiles.splice(parseInt(b.dataset.i), 1);
            renderList();
        });
    });
}

resetBtn.addEventListener('click', () => {
    videoFiles = []; zipBlob = null;
    renderList();
    progressPanel.classList.remove('show');
    summary.classList.remove('show');
    progFill.style.width = '0%';
});

// START
startBtn.addEventListener('click', async () => {
    if (!videoFiles.length) return;
    startBtn.disabled = true;
    resetBtn.disabled = true;
    summary.classList.remove('show');
    progressPanel.classList.add('show');

    const allFiles = [];
    let totalFrames = 0;

    for (let i = 0; i < videoFiles.length; i++) {
        const entry = videoFiles[i];
        entry.status = 'processing';
        renderList();
        setProgress(i, videoFiles.length, 'Video ' + (i+1) + '/' + videoFiles.length + ': ' + entry.file.name, '');

        try {
            const frames = await extractFrames(entry.file, interval, msg => { progDetail.textContent = msg; });
            const baseName = entry.file.name.replace(/\.[^/.]+$/, '');
            frames.forEach(f => allFiles.push({ name: baseName + '/' + f.name, data: f.data }));
            entry.status = 'done';
            entry.frames = frames.length;
            totalFrames += frames.length;
        } catch (err) {
            entry.status = 'error';
            console.error(err);
        }
        renderList();
    }

    progLabel.textContent = 'ZIP wird erstellt …';
    progDetail.textContent = allFiles.length + ' Dateien werden gepackt …';
    progFill.style.width = '95%'; progPct.textContent = '…';

    const zipBytes = await MiniZip.build(allFiles);
    zipBlob = new Blob([zipBytes], { type: 'application/zip' });

    progressPanel.classList.remove('show');
    summary.classList.add('show');
    const doneCount = videoFiles.filter(e => e.status === 'done').length;
    summaryText.textContent =
        doneCount + ' Video' + (doneCount !== 1 ? 's' : '') +
        ' verarbeitet · ' + totalFrames + ' Frames extrahiert';
    resetBtn.disabled = false;
});

dlBtn.addEventListener('click', () => {
    if (!zipBlob) return;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(zipBlob);
    a.download = 'frames_export.zip';
    a.click();
});

function setProgress(done, total, label, detail) {
    const pct = total > 0 ? Math.round(done / total * 100) : 0;
    progFill.style.width = pct + '%';
    progPct.textContent = pct + '%';
    progLabel.textContent = label;
    progDetail.textContent = detail;
}

// FRAME EXTRACTION
function extractFrames(file, iv, onProgress) {
    return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const video = document.createElement('video');
        video.muted = true;
        video.preload = 'auto';
        video.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Videofehler')); };

        video.addEventListener('loadedmetadata', async () => {
            const duration = video.duration;
            const fps = 30;
            const totalFrameCount = Math.round(duration * fps);

            canvas.width  = video.videoWidth  || 1280;
            canvas.height = video.videoHeight || 720;

            let times = [];
            if (iv === 'last') {
                times = [Math.max(0, duration - 0.05)];
            } else {
                for (let f = iv - 1; f < totalFrameCount; f += iv) {
                    times.push(f / fps);
                }
                const lastT = Math.max(0, duration - 0.05);
                if (!times.length || times[times.length - 1] < lastT - 0.1) times.push(lastT);
            }

            const results = [];
            for (let i = 0; i < times.length; i++) {
                try {
                    const blob = await seekCapture(video, times[i]);
                    const arr  = await blob.arrayBuffer();
                    const frameNum = iv === 'last'
                        ? 'last'
                        : String(Math.round(times[i] * fps) + 1).padStart(6, '0');
                    results.push({ name: 'frame_' + frameNum + '.jpg', data: new Uint8Array(arr) });
                    onProgress('Frame ' + (i + 1) + ' / ' + times.length);
                } catch(e) { /* skip */ }
            }

            URL.revokeObjectURL(url);
            video.remove();
            resolve(results);
        });

        video.src = url;
        video.load();
    });
}

function seekCapture(video, time) {
    return new Promise((resolve, reject) => {
        const tid = setTimeout(() => reject(new Error('Seek timeout')), 12000);
        video.onseeked = () => {
            clearTimeout(tid);
            video.onseeked = null;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(b => {
                b ? resolve(b) : reject(new Error('Blob-Fehler'));
            }, 'image/jpeg', 0.92);
        };
        video.currentTime = time;
    });
}
</script>
</body>
</html>